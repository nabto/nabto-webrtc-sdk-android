/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.PostTestClient200Response
import org.openapitools.client.models.PostTestClientByTestIdGetActiveWebsockets200Response
import org.openapitools.client.models.PostTestClientByTestIdSendDeviceErrorRequest
import org.openapitools.client.models.PostTestClientByTestIdSendDeviceMessagesRequest
import org.openapitools.client.models.PostTestClientByTestIdWaitForDeviceError200Response
import org.openapitools.client.models.PostTestClientByTestIdWaitForDeviceErrorRequest
import org.openapitools.client.models.PostTestClientByTestIdWaitForDeviceMessages200Response
import org.openapitools.client.models.PostTestClientByTestIdWaitForDeviceMessagesRequest
import org.openapitools.client.models.PostTestClientRequest
import org.openapitools.client.models.PostTestDeviceByTestIdClients200Response
import org.openapitools.client.models.PostTestDeviceByTestIdClientsByClientIdWaitForErrorRequest
import org.openapitools.client.models.PostTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest
import org.openapitools.client.models.PostTestDeviceRequest
import org.openapitools.client.models.PostV1ClientConnect200Response
import org.openapitools.client.models.PostV1ClientConnect400Response
import org.openapitools.client.models.PostV1ClientConnectRequest
import org.openapitools.client.models.PostV1DeviceConnect200Response
import org.openapitools.client.models.PostV1IceServers200Response
import org.openapitools.client.models.PostV1IceServers400Response

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost")
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTestClientByTestId(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteTestClientByTestIdWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTestClientByTestIdWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteTestClientByTestIdRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTestClientByTestId
     *
     * @param testId 
     * @return RequestConfig
     */
    fun deleteTestClientByTestIdRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/test/client/{testId}".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTestDeviceByTestId(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = deleteTestDeviceByTestIdWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTestDeviceByTestIdWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = deleteTestDeviceByTestIdRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTestDeviceByTestId
     *
     * @param testId 
     * @return RequestConfig
     */
    fun deleteTestDeviceByTestIdRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/test/device/{testId}".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param postTestClientRequest 
     * @return PostTestClient200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClient(postTestClientRequest: PostTestClientRequest) : PostTestClient200Response {
        val localVarResponse = postTestClientWithHttpInfo(postTestClientRequest = postTestClientRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClient200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param postTestClientRequest 
     * @return ApiResponse<PostTestClient200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientWithHttpInfo(postTestClientRequest: PostTestClientRequest) : ApiResponse<PostTestClient200Response?> {
        val localVariableConfig = postTestClientRequestConfig(postTestClientRequest = postTestClientRequest)

        return request<PostTestClientRequest, PostTestClient200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClient
     *
     * @param postTestClientRequest 
     * @return RequestConfig
     */
    fun postTestClientRequestConfig(postTestClientRequest: PostTestClientRequest) : RequestConfig<PostTestClientRequest> {
        val localVariableBody = postTestClientRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdConnectDevice(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdConnectDeviceWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdConnectDeviceWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdConnectDeviceRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdConnectDevice
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestClientByTestIdConnectDeviceRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/connect-device".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdDisconnectClient(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdDisconnectClientWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdDisconnectClientWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdDisconnectClientRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdDisconnectClient
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestClientByTestIdDisconnectClientRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/disconnect-client".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdDisconnectDevice(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdDisconnectDeviceWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdDisconnectDeviceWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdDisconnectDeviceRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdDisconnectDevice
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestClientByTestIdDisconnectDeviceRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/disconnect-device".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdDropClientMessages(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdDropClientMessagesWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdDropClientMessagesWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdDropClientMessagesRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdDropClientMessages
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestClientByTestIdDropClientMessagesRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/drop-client-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdDropDeviceMessages(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdDropDeviceMessagesWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdDropDeviceMessagesWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdDropDeviceMessagesRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdDropDeviceMessages
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestClientByTestIdDropDeviceMessagesRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/drop-device-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param body 
     * @return PostTestClientByTestIdGetActiveWebsockets200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdGetActiveWebsockets(testId: kotlin.String, body: kotlin.Any) : PostTestClientByTestIdGetActiveWebsockets200Response {
        val localVarResponse = postTestClientByTestIdGetActiveWebsocketsWithHttpInfo(testId = testId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClientByTestIdGetActiveWebsockets200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param body 
     * @return ApiResponse<PostTestClientByTestIdGetActiveWebsockets200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdGetActiveWebsocketsWithHttpInfo(testId: kotlin.String, body: kotlin.Any) : ApiResponse<PostTestClientByTestIdGetActiveWebsockets200Response?> {
        val localVariableConfig = postTestClientByTestIdGetActiveWebsocketsRequestConfig(testId = testId, body = body)

        return request<kotlin.Any, PostTestClientByTestIdGetActiveWebsockets200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdGetActiveWebsockets
     *
     * @param testId 
     * @param body 
     * @return RequestConfig
     */
    fun postTestClientByTestIdGetActiveWebsocketsRequestConfig(testId: kotlin.String, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/get-active-websockets".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdSendDeviceErrorRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdSendDeviceError(testId: kotlin.String, postTestClientByTestIdSendDeviceErrorRequest: PostTestClientByTestIdSendDeviceErrorRequest) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdSendDeviceErrorWithHttpInfo(testId = testId, postTestClientByTestIdSendDeviceErrorRequest = postTestClientByTestIdSendDeviceErrorRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdSendDeviceErrorRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdSendDeviceErrorWithHttpInfo(testId: kotlin.String, postTestClientByTestIdSendDeviceErrorRequest: PostTestClientByTestIdSendDeviceErrorRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdSendDeviceErrorRequestConfig(testId = testId, postTestClientByTestIdSendDeviceErrorRequest = postTestClientByTestIdSendDeviceErrorRequest)

        return request<PostTestClientByTestIdSendDeviceErrorRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdSendDeviceError
     *
     * @param testId 
     * @param postTestClientByTestIdSendDeviceErrorRequest 
     * @return RequestConfig
     */
    fun postTestClientByTestIdSendDeviceErrorRequestConfig(testId: kotlin.String, postTestClientByTestIdSendDeviceErrorRequest: PostTestClientByTestIdSendDeviceErrorRequest) : RequestConfig<PostTestClientByTestIdSendDeviceErrorRequest> {
        val localVariableBody = postTestClientByTestIdSendDeviceErrorRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/send-device-error".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdSendDeviceMessagesRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdSendDeviceMessages(testId: kotlin.String, postTestClientByTestIdSendDeviceMessagesRequest: PostTestClientByTestIdSendDeviceMessagesRequest) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdSendDeviceMessagesWithHttpInfo(testId = testId, postTestClientByTestIdSendDeviceMessagesRequest = postTestClientByTestIdSendDeviceMessagesRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdSendDeviceMessagesRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdSendDeviceMessagesWithHttpInfo(testId: kotlin.String, postTestClientByTestIdSendDeviceMessagesRequest: PostTestClientByTestIdSendDeviceMessagesRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdSendDeviceMessagesRequestConfig(testId = testId, postTestClientByTestIdSendDeviceMessagesRequest = postTestClientByTestIdSendDeviceMessagesRequest)

        return request<PostTestClientByTestIdSendDeviceMessagesRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdSendDeviceMessages
     *
     * @param testId 
     * @param postTestClientByTestIdSendDeviceMessagesRequest 
     * @return RequestConfig
     */
    fun postTestClientByTestIdSendDeviceMessagesRequestConfig(testId: kotlin.String, postTestClientByTestIdSendDeviceMessagesRequest: PostTestClientByTestIdSendDeviceMessagesRequest) : RequestConfig<PostTestClientByTestIdSendDeviceMessagesRequest> {
        val localVariableBody = postTestClientByTestIdSendDeviceMessagesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/send-device-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param body 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdSendNewFieldInKnownMessageType(testId: kotlin.String, body: kotlin.Any) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdSendNewFieldInKnownMessageTypeWithHttpInfo(testId = testId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param body 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdSendNewFieldInKnownMessageTypeWithHttpInfo(testId: kotlin.String, body: kotlin.Any) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdSendNewFieldInKnownMessageTypeRequestConfig(testId = testId, body = body)

        return request<kotlin.Any, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdSendNewFieldInKnownMessageType
     *
     * @param testId 
     * @param body 
     * @return RequestConfig
     */
    fun postTestClientByTestIdSendNewFieldInKnownMessageTypeRequestConfig(testId: kotlin.String, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/send-new-field-in-known-message-type".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param body 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdSendNewMessageType(testId: kotlin.String, body: kotlin.Any) : kotlin.Any {
        val localVarResponse = postTestClientByTestIdSendNewMessageTypeWithHttpInfo(testId = testId, body = body)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param body 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdSendNewMessageTypeWithHttpInfo(testId: kotlin.String, body: kotlin.Any) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestClientByTestIdSendNewMessageTypeRequestConfig(testId = testId, body = body)

        return request<kotlin.Any, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdSendNewMessageType
     *
     * @param testId 
     * @param body 
     * @return RequestConfig
     */
    fun postTestClientByTestIdSendNewMessageTypeRequestConfig(testId: kotlin.String, body: kotlin.Any) : RequestConfig<kotlin.Any> {
        val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/send-new-message-type".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdWaitForDeviceErrorRequest 
     * @return PostTestClientByTestIdWaitForDeviceError200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdWaitForDeviceError(testId: kotlin.String, postTestClientByTestIdWaitForDeviceErrorRequest: PostTestClientByTestIdWaitForDeviceErrorRequest) : PostTestClientByTestIdWaitForDeviceError200Response {
        val localVarResponse = postTestClientByTestIdWaitForDeviceErrorWithHttpInfo(testId = testId, postTestClientByTestIdWaitForDeviceErrorRequest = postTestClientByTestIdWaitForDeviceErrorRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClientByTestIdWaitForDeviceError200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdWaitForDeviceErrorRequest 
     * @return ApiResponse<PostTestClientByTestIdWaitForDeviceError200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdWaitForDeviceErrorWithHttpInfo(testId: kotlin.String, postTestClientByTestIdWaitForDeviceErrorRequest: PostTestClientByTestIdWaitForDeviceErrorRequest) : ApiResponse<PostTestClientByTestIdWaitForDeviceError200Response?> {
        val localVariableConfig = postTestClientByTestIdWaitForDeviceErrorRequestConfig(testId = testId, postTestClientByTestIdWaitForDeviceErrorRequest = postTestClientByTestIdWaitForDeviceErrorRequest)

        return request<PostTestClientByTestIdWaitForDeviceErrorRequest, PostTestClientByTestIdWaitForDeviceError200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdWaitForDeviceError
     *
     * @param testId 
     * @param postTestClientByTestIdWaitForDeviceErrorRequest 
     * @return RequestConfig
     */
    fun postTestClientByTestIdWaitForDeviceErrorRequestConfig(testId: kotlin.String, postTestClientByTestIdWaitForDeviceErrorRequest: PostTestClientByTestIdWaitForDeviceErrorRequest) : RequestConfig<PostTestClientByTestIdWaitForDeviceErrorRequest> {
        val localVariableBody = postTestClientByTestIdWaitForDeviceErrorRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/wait-for-device-error".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdWaitForDeviceMessagesRequest 
     * @return PostTestClientByTestIdWaitForDeviceMessages200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestClientByTestIdWaitForDeviceMessages(testId: kotlin.String, postTestClientByTestIdWaitForDeviceMessagesRequest: PostTestClientByTestIdWaitForDeviceMessagesRequest) : PostTestClientByTestIdWaitForDeviceMessages200Response {
        val localVarResponse = postTestClientByTestIdWaitForDeviceMessagesWithHttpInfo(testId = testId, postTestClientByTestIdWaitForDeviceMessagesRequest = postTestClientByTestIdWaitForDeviceMessagesRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClientByTestIdWaitForDeviceMessages200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param postTestClientByTestIdWaitForDeviceMessagesRequest 
     * @return ApiResponse<PostTestClientByTestIdWaitForDeviceMessages200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestClientByTestIdWaitForDeviceMessagesWithHttpInfo(testId: kotlin.String, postTestClientByTestIdWaitForDeviceMessagesRequest: PostTestClientByTestIdWaitForDeviceMessagesRequest) : ApiResponse<PostTestClientByTestIdWaitForDeviceMessages200Response?> {
        val localVariableConfig = postTestClientByTestIdWaitForDeviceMessagesRequestConfig(testId = testId, postTestClientByTestIdWaitForDeviceMessagesRequest = postTestClientByTestIdWaitForDeviceMessagesRequest)

        return request<PostTestClientByTestIdWaitForDeviceMessagesRequest, PostTestClientByTestIdWaitForDeviceMessages200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestClientByTestIdWaitForDeviceMessages
     *
     * @param testId 
     * @param postTestClientByTestIdWaitForDeviceMessagesRequest 
     * @return RequestConfig
     */
    fun postTestClientByTestIdWaitForDeviceMessagesRequestConfig(testId: kotlin.String, postTestClientByTestIdWaitForDeviceMessagesRequest: PostTestClientByTestIdWaitForDeviceMessagesRequest) : RequestConfig<PostTestClientByTestIdWaitForDeviceMessagesRequest> {
        val localVariableBody = postTestClientByTestIdWaitForDeviceMessagesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/client/{testId}/wait-for-device-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param postTestDeviceRequest 
     * @return PostTestClient200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDevice(postTestDeviceRequest: PostTestDeviceRequest) : PostTestClient200Response {
        val localVarResponse = postTestDeviceWithHttpInfo(postTestDeviceRequest = postTestDeviceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClient200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param postTestDeviceRequest 
     * @return ApiResponse<PostTestClient200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceWithHttpInfo(postTestDeviceRequest: PostTestDeviceRequest) : ApiResponse<PostTestClient200Response?> {
        val localVariableConfig = postTestDeviceRequestConfig(postTestDeviceRequest = postTestDeviceRequest)

        return request<PostTestDeviceRequest, PostTestClient200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDevice
     *
     * @param postTestDeviceRequest 
     * @return RequestConfig
     */
    fun postTestDeviceRequestConfig(postTestDeviceRequest: PostTestDeviceRequest) : RequestConfig<PostTestDeviceRequest> {
        val localVariableBody = postTestDeviceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return PostTestDeviceByTestIdClients200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClients(testId: kotlin.String) : PostTestDeviceByTestIdClients200Response {
        val localVarResponse = postTestDeviceByTestIdClientsWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestDeviceByTestIdClients200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<PostTestDeviceByTestIdClients200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsWithHttpInfo(testId: kotlin.String) : ApiResponse<PostTestDeviceByTestIdClients200Response?> {
        val localVariableConfig = postTestDeviceByTestIdClientsRequestConfig(testId = testId)

        return request<Unit, PostTestDeviceByTestIdClients200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClients
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdConnect(testId: kotlin.String, clientId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdConnectWithHttpInfo(testId = testId, clientId = clientId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdConnectWithHttpInfo(testId: kotlin.String, clientId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdConnectRequestConfig(testId = testId, clientId = clientId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdConnect
     *
     * @param testId 
     * @param clientId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdConnectRequestConfig(testId: kotlin.String, clientId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/connect".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdDisconnect(testId: kotlin.String, clientId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdDisconnectWithHttpInfo(testId = testId, clientId = clientId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdDisconnectWithHttpInfo(testId: kotlin.String, clientId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdDisconnectRequestConfig(testId = testId, clientId = clientId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdDisconnect
     *
     * @param testId 
     * @param clientId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdDisconnectRequestConfig(testId: kotlin.String, clientId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/disconnect".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdDropClientMessages(testId: kotlin.String, clientId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdDropClientMessagesWithHttpInfo(testId = testId, clientId = clientId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdDropClientMessagesWithHttpInfo(testId: kotlin.String, clientId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdDropClientMessagesRequestConfig(testId = testId, clientId = clientId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdDropClientMessages
     *
     * @param testId 
     * @param clientId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdDropClientMessagesRequestConfig(testId: kotlin.String, clientId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/drop-client-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestClientByTestIdSendDeviceErrorRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdSendError(testId: kotlin.String, clientId: kotlin.String, postTestClientByTestIdSendDeviceErrorRequest: PostTestClientByTestIdSendDeviceErrorRequest) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdSendErrorWithHttpInfo(testId = testId, clientId = clientId, postTestClientByTestIdSendDeviceErrorRequest = postTestClientByTestIdSendDeviceErrorRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestClientByTestIdSendDeviceErrorRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdSendErrorWithHttpInfo(testId: kotlin.String, clientId: kotlin.String, postTestClientByTestIdSendDeviceErrorRequest: PostTestClientByTestIdSendDeviceErrorRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdSendErrorRequestConfig(testId = testId, clientId = clientId, postTestClientByTestIdSendDeviceErrorRequest = postTestClientByTestIdSendDeviceErrorRequest)

        return request<PostTestClientByTestIdSendDeviceErrorRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdSendError
     *
     * @param testId 
     * @param clientId 
     * @param postTestClientByTestIdSendDeviceErrorRequest 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdSendErrorRequestConfig(testId: kotlin.String, clientId: kotlin.String, postTestClientByTestIdSendDeviceErrorRequest: PostTestClientByTestIdSendDeviceErrorRequest) : RequestConfig<PostTestClientByTestIdSendDeviceErrorRequest> {
        val localVariableBody = postTestClientByTestIdSendDeviceErrorRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/send-error".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestClientByTestIdSendDeviceMessagesRequest 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdSendMessages(testId: kotlin.String, clientId: kotlin.String, postTestClientByTestIdSendDeviceMessagesRequest: PostTestClientByTestIdSendDeviceMessagesRequest) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdSendMessagesWithHttpInfo(testId = testId, clientId = clientId, postTestClientByTestIdSendDeviceMessagesRequest = postTestClientByTestIdSendDeviceMessagesRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestClientByTestIdSendDeviceMessagesRequest 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdSendMessagesWithHttpInfo(testId: kotlin.String, clientId: kotlin.String, postTestClientByTestIdSendDeviceMessagesRequest: PostTestClientByTestIdSendDeviceMessagesRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdSendMessagesRequestConfig(testId = testId, clientId = clientId, postTestClientByTestIdSendDeviceMessagesRequest = postTestClientByTestIdSendDeviceMessagesRequest)

        return request<PostTestClientByTestIdSendDeviceMessagesRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdSendMessages
     *
     * @param testId 
     * @param clientId 
     * @param postTestClientByTestIdSendDeviceMessagesRequest 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdSendMessagesRequestConfig(testId: kotlin.String, clientId: kotlin.String, postTestClientByTestIdSendDeviceMessagesRequest: PostTestClientByTestIdSendDeviceMessagesRequest) : RequestConfig<PostTestClientByTestIdSendDeviceMessagesRequest> {
        val localVariableBody = postTestClientByTestIdSendDeviceMessagesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/send-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest 
     * @return PostTestClientByTestIdSendDeviceErrorRequest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdWaitForError(testId: kotlin.String, clientId: kotlin.String, postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest: PostTestDeviceByTestIdClientsByClientIdWaitForErrorRequest) : PostTestClientByTestIdSendDeviceErrorRequest {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdWaitForErrorWithHttpInfo(testId = testId, clientId = clientId, postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest = postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClientByTestIdSendDeviceErrorRequest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest 
     * @return ApiResponse<PostTestClientByTestIdSendDeviceErrorRequest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdWaitForErrorWithHttpInfo(testId: kotlin.String, clientId: kotlin.String, postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest: PostTestDeviceByTestIdClientsByClientIdWaitForErrorRequest) : ApiResponse<PostTestClientByTestIdSendDeviceErrorRequest?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdWaitForErrorRequestConfig(testId = testId, clientId = clientId, postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest = postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest)

        return request<PostTestDeviceByTestIdClientsByClientIdWaitForErrorRequest, PostTestClientByTestIdSendDeviceErrorRequest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdWaitForError
     *
     * @param testId 
     * @param clientId 
     * @param postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdWaitForErrorRequestConfig(testId: kotlin.String, clientId: kotlin.String, postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest: PostTestDeviceByTestIdClientsByClientIdWaitForErrorRequest) : RequestConfig<PostTestDeviceByTestIdClientsByClientIdWaitForErrorRequest> {
        val localVariableBody = postTestDeviceByTestIdClientsByClientIdWaitForErrorRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/wait-for-error".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest 
     * @return PostTestClientByTestIdWaitForDeviceMessages200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdClientsByClientIdWaitForMessages(testId: kotlin.String, clientId: kotlin.String, postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest: PostTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest) : PostTestClientByTestIdWaitForDeviceMessages200Response {
        val localVarResponse = postTestDeviceByTestIdClientsByClientIdWaitForMessagesWithHttpInfo(testId = testId, clientId = clientId, postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest = postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostTestClientByTestIdWaitForDeviceMessages200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @param clientId 
     * @param postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest 
     * @return ApiResponse<PostTestClientByTestIdWaitForDeviceMessages200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdClientsByClientIdWaitForMessagesWithHttpInfo(testId: kotlin.String, clientId: kotlin.String, postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest: PostTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest) : ApiResponse<PostTestClientByTestIdWaitForDeviceMessages200Response?> {
        val localVariableConfig = postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequestConfig(testId = testId, clientId = clientId, postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest = postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest)

        return request<PostTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest, PostTestClientByTestIdWaitForDeviceMessages200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdClientsByClientIdWaitForMessages
     *
     * @param testId 
     * @param clientId 
     * @param postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequestConfig(testId: kotlin.String, clientId: kotlin.String, postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest: PostTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest) : RequestConfig<PostTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest> {
        val localVariableBody = postTestDeviceByTestIdClientsByClientIdWaitForMessagesRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/clients/{clientId}/wait-for-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())).replace("{"+"clientId"+"}", encodeURIComponent(clientId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdDisconnectDevice(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdDisconnectDeviceWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdDisconnectDeviceWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdDisconnectDeviceRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdDisconnectDevice
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdDisconnectDeviceRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/disconnect-device".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdDropDeviceMessages(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdDropDeviceMessagesWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdDropDeviceMessagesWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdDropDeviceMessagesRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdDropDeviceMessages
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdDropDeviceMessagesRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/drop-device-messages".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param testId 
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postTestDeviceByTestIdSendNewMessageType(testId: kotlin.String) : kotlin.Any {
        val localVarResponse = postTestDeviceByTestIdSendNewMessageTypeWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param testId 
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postTestDeviceByTestIdSendNewMessageTypeWithHttpInfo(testId: kotlin.String) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = postTestDeviceByTestIdSendNewMessageTypeRequestConfig(testId = testId)

        return request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postTestDeviceByTestIdSendNewMessageType
     *
     * @param testId 
     * @return RequestConfig
     */
    fun postTestDeviceByTestIdSendNewMessageTypeRequestConfig(testId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/test/device/{testId}/send-new-message-type".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param postV1ClientConnectRequest 
     * @param authorization  (optional)
     * @return PostV1ClientConnect200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postV1ClientConnect(postV1ClientConnectRequest: PostV1ClientConnectRequest, authorization: kotlin.String? = null) : PostV1ClientConnect200Response {
        val localVarResponse = postV1ClientConnectWithHttpInfo(postV1ClientConnectRequest = postV1ClientConnectRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostV1ClientConnect200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param postV1ClientConnectRequest 
     * @param authorization  (optional)
     * @return ApiResponse<PostV1ClientConnect200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postV1ClientConnectWithHttpInfo(postV1ClientConnectRequest: PostV1ClientConnectRequest, authorization: kotlin.String?) : ApiResponse<PostV1ClientConnect200Response?> {
        val localVariableConfig = postV1ClientConnectRequestConfig(postV1ClientConnectRequest = postV1ClientConnectRequest, authorization = authorization)

        return request<PostV1ClientConnectRequest, PostV1ClientConnect200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postV1ClientConnect
     *
     * @param postV1ClientConnectRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun postV1ClientConnectRequestConfig(postV1ClientConnectRequest: PostV1ClientConnectRequest, authorization: kotlin.String?) : RequestConfig<PostV1ClientConnectRequest> {
        val localVariableBody = postV1ClientConnectRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/client/connect",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param authorization 
     * @param postV1ClientConnectRequest 
     * @return PostV1DeviceConnect200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postV1DeviceConnect(authorization: kotlin.String, postV1ClientConnectRequest: PostV1ClientConnectRequest) : PostV1DeviceConnect200Response {
        val localVarResponse = postV1DeviceConnectWithHttpInfo(authorization = authorization, postV1ClientConnectRequest = postV1ClientConnectRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostV1DeviceConnect200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param authorization 
     * @param postV1ClientConnectRequest 
     * @return ApiResponse<PostV1DeviceConnect200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postV1DeviceConnectWithHttpInfo(authorization: kotlin.String, postV1ClientConnectRequest: PostV1ClientConnectRequest) : ApiResponse<PostV1DeviceConnect200Response?> {
        val localVariableConfig = postV1DeviceConnectRequestConfig(authorization = authorization, postV1ClientConnectRequest = postV1ClientConnectRequest)

        return request<PostV1ClientConnectRequest, PostV1DeviceConnect200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postV1DeviceConnect
     *
     * @param authorization 
     * @param postV1ClientConnectRequest 
     * @return RequestConfig
     */
    fun postV1DeviceConnectRequestConfig(authorization: kotlin.String, postV1ClientConnectRequest: PostV1ClientConnectRequest) : RequestConfig<PostV1ClientConnectRequest> {
        val localVariableBody = postV1ClientConnectRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/device/connect",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * 
     * 
     * @param postV1ClientConnectRequest 
     * @param authorization  (optional)
     * @return PostV1IceServers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postV1IceServers(postV1ClientConnectRequest: PostV1ClientConnectRequest, authorization: kotlin.String? = null) : PostV1IceServers200Response {
        val localVarResponse = postV1IceServersWithHttpInfo(postV1ClientConnectRequest = postV1ClientConnectRequest, authorization = authorization)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PostV1IceServers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * 
     * 
     * @param postV1ClientConnectRequest 
     * @param authorization  (optional)
     * @return ApiResponse<PostV1IceServers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postV1IceServersWithHttpInfo(postV1ClientConnectRequest: PostV1ClientConnectRequest, authorization: kotlin.String?) : ApiResponse<PostV1IceServers200Response?> {
        val localVariableConfig = postV1IceServersRequestConfig(postV1ClientConnectRequest = postV1ClientConnectRequest, authorization = authorization)

        return request<PostV1ClientConnectRequest, PostV1IceServers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postV1IceServers
     *
     * @param postV1ClientConnectRequest 
     * @param authorization  (optional)
     * @return RequestConfig
     */
    fun postV1IceServersRequestConfig(postV1ClientConnectRequest: PostV1ClientConnectRequest, authorization: kotlin.String?) : RequestConfig<PostV1ClientConnectRequest> {
        val localVariableBody = postV1ClientConnectRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json, multipart/form-data"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/ice-servers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
